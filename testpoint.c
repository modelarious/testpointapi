/*XXXXXXXXX must be initialized before any forking is done or else the other processes won't be able to access it */
/* could replace all the "failed in test point api: %d %s, errno, strerror(errno));" with a #define */
/* need to be different copies of shared memory object so different tests can run concurrently */
/* timestamp in struct? cleanup goes and looks for old timestamps */
/* should I dup2() the stderr and stdout file descriptors incase someone closes them? */

/* anything but ERROR ends testpoint. Error is not a test state, unres, fail and pass are. It is up to you to 
call pointfail after errors.  Recommended: create functions to run each testpoint.  if any error codes
are generated by any functions, then pointerrormsg() and return EXIT_FAILURE.  The code looking for the return
value should then fail the test with pointfail() */

/* must call before forking */

#ifndef EOK
#define EOK 0
#endif

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <sys/types.h>
#include <errno.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>        /* For mode constants */
#include <fcntl.h>           /* For O_* constants */

#define SHMEM_PATH "/tmp/testpoint"

/* check if test_info is uninitialized, if that is the case, 
print a message and return a failure */
#define return_fail_on_no_shared_memory if (test_info == NULL) { \
                                            printf("ERROR:\ttest_info not initialized. "\
                                            "Make sure to call teststart()\n"); \
                                            return EXIT_FAILURE; \
                                        }
/* increment the state passed in as "state" and return EXIT_SUCCESS */
#define increment_state_and_return_success(state) test_info->test_results[state]++; \
                                                  return EXIT_SUCCESS;

typedef enum {
	PASS=0,
	FAIL,
	UNRES,
	ERROR,
	POINT,
	/* add states here */
	
	NUMBER_OF_STATES
} test_state_t;

typedef struct {
	long test_results[NUMBER_OF_STATES]; /* array indexed by test_state_t */
	pthread_mutex_t mutexes[NUMBER_OF_STATES]; /* lock to modify test_results */
	pthread_mutex_t exclusive_print; /* lock so only one test point message can occur at a time */
} test_info_t;

/* in shared memory */
test_info_t * test_info = NULL;

/* print out a descriptive error message */
void error_print(char *funcName, int rc) {
	fprintf(stderr, "%s() failed in point api: %d %s\n", funcName,
		rc, strerror(rc));
	fflush(stderr);
}

/* sets values in shared memory to defaults, initializes mutexes */
int init_test_info() {
	pthread_mutexattr_t attr;
	int rc;
	
	/* setup test_info */
	if (test_info) {
		memset(test_info, 0, sizeof(test_info_t));
		
		/* create attributes */
		if ((rc = pthread_mutexattr_init(&attr)) != EOK) {
			error_print("pthread_mutexattr_init", rc);
			return EXIT_FAILURE;
		}
		
		/* as this will be shared across processes, must set
		 * PTHREAD_PROCESS_SHARED */
		if ((rc = pthread_mutexattr_setpshared(&attr, 
			PTHREAD_PROCESS_SHARED)) != EOK) {
			error_print("pthread_mutexattr_setpshared", rc);
			return EXIT_FAILURE;
		}
		
		/* initialize mutexes */
		for (int i = PASS; i < NUMBER_OF_STATES; i++) {
			if ((rc = pthread_mutex_init(&test_info->mutexes[i], &attr)) != EOK) {
				error_print("pthread_mutex_init", rc);
				return EXIT_FAILURE;
			}
		}
		
		/* initialize mutex for exclusive printing */
		//XXX #define EXCLUSIVE_PRINTING 
		if ((rc = pthread_mutex_init(&test_info->exclusive_print, &attr)) != EOK) {
			error_print("pthread_mutex_init", rc);
			return EXIT_FAILURE;
		}
		
		return EXIT_SUCCESS;
	}
	return EXIT_FAILURE;
}
	
/* returns success on already initialized or successful initialization */
int init_shared_memory() {
	int fd, rc;
	char shmem_path[500];
	
	if (test_info) {
		fprintf(stderr, "test_info already initialized\n");
		return EXIT_SUCCESS;
	}
	
	/* set the shared memory path to ${SHMEM_PATH}_${PID} */
	sprintf(shmem_path, "%s_%d", SHMEM_PATH, getpid());
	
	/* open shared memory object */
	fd = shm_open(shmem_path, 
		O_CREAT| /* create if non existant */
		//O_TRUNC| /* truncate to 0 if already existing */
		O_RDWR, /* open for reading and writing */
		S_IRWXU /* user has read, write and execute */
	);
	
	/* fd should be nonnegative */
	if (fd < 0) {
		error_print("shm_open", errno);
		return EXIT_FAILURE;
	}
	
	/* resize using fd */
	rc = ftruncate(fd, sizeof(test_info_t)); //size of test_info_t
	
	/* error handle */
	if (rc != EOK) {
		error_print("ftruncate", errno);
		return EXIT_FAILURE;
	}
	
	/* map shared memory to test_info */
	test_info = mmap(NULL, sizeof(test_info_t), 
		//PROT_EXEC|
		PROT_READ|
		PROT_WRITE, /* read/write/exec */
		MAP_SHARED, /* shared memory */
		fd, 0 );
	
	/* error handle */
	if (test_info == MAP_FAILED) {
		error_print("mmap", errno);
		return EXIT_FAILURE;
	}
	
	/* done with fd */
	close(fd);
	
	return EXIT_SUCCESS;
}


int increment_state(test_state_t state) {

	/* increase occurrence of passed in state */
	if (pthread_mutex_lock(&test_info->mutexes[state]) != EOK) {
		printf("pthread_mutex_lock"); //XXX
		return EXIT_FAILURE;
	}
	
	test_info->test_results[state]++;

	if (pthread_mutex_unlock(&test_info->mutexes[state]) != EOK) {
		printf("pthread_mutex_lock"); //XXX
		return EXIT_FAILURE;
	}
	
	return EXIT_SUCCESS;

}


/* print the formatted output passed into a test point function,
 * increment the occurrence count of the passed in "state" */
 /* maybe store every message in a database? XXX */
int __printf (FILE * filestream, test_state_t state, char *apiMessage, char * str, ...)
{
	va_list arg;
	
	/* if test info is not initialized yet, return EXIT_FAILURE */
	if (test_info == NULL) {
		printf("ERROR:\ttest_info not initialized. "
			"Make sure to call teststart()\n");
    	return EXIT_FAILURE; 
	}

	/* to ensure only one message is ever printed at a time,
	 * lock the exclusive print mutex */
	 //XXX #define EXCLUSIVE_PRINTING
	if (pthread_mutex_lock(&test_info->exclusive_print) != EOK) {
		printf("pthread_mutex_lock"); //XXX
		return EXIT_FAILURE;
	}
	
	/* print: 
		apiMessage ":\t" str "\n" 
	*/
	/* vsprintf may be able to help you XXX */
	va_start (arg, str);
	fprintf(filestream, "%s:\t", apiMessage);
	vfprintf(filestream, str, arg);
	fprintf(filestream, "\n");
	va_end (arg);
	fflush(filestream);
	
	/* to ensure only one message is ever printed at a time,
	 * lock the exclusive print mutex */
	 //XXX #define EXCLUSIVE_PRINTING
	if (pthread_mutex_unlock(&test_info->exclusive_print) != EOK) {
		printf("pthread_mutex_unlock"); //XXX
		return EXIT_FAILURE;
	}
	
	/* state == POINT indicates we are just printing information
	and exiting XXX could we make this based on apiMessage? although if we end up using vsprintf to pass some 
	nicely formatted string, that ability would go away */
	if (state == POINT) {
		return EXIT_SUCCESS;
	}
	
	/* increment the passed in state */
	if (increment_state(state) != EXIT_SUCCESS) {
		return EXIT_FAILURE;
	}
	
	/* if passed in stat is not error, 
	increase test point count too */
	if (state != ERROR) {
		return increment_state(POINT);
    }
    
    return EXIT_SUCCESS;

}

int testinit() {
	/* initialize shared memory and mmap it to test_info pointer */
	if (init_shared_memory() != EXIT_SUCCESS) {
		return EXIT_FAILURE;
	}
	
	/* set default values and initialize mutexes */
	if (init_test_info() != EXIT_SUCCESS) {
		return EXIT_FAILURE;
	}
	
	return EXIT_SUCCESS;
}
	
int testnote(char * str) {
	return __printf(stdout, POINT, "NOTE", str);
}

int teststart(char * str) {

	/* if successfully initialize shared memory, print start message */
	if (testinit() == EXIT_SUCCESS) {
		return __printf(stdout, POINT, "START", str);
	}
	return EXIT_FAILURE;
}

int pointstart(char * str) {
	return __printf(stdout, POINT, "TEST", str);
}

int pointpass(char * str) {
	return __printf(stdout, PASS, "PASS", str);
}

int pointfail(char * str) {
	return __printf(stdout, FAIL, "FAIL", str);
}

int pointerrormsg(char *str) {
	return __printf(stdout, ERROR, "ERROR", str);
}

int pointunres(char * str) {
	return __printf(stdout, UNRES, "UNRES", str);
}

int pointdone() {
	return EXIT_SUCCESS;
}

int testend(char * str) {
	char shmem_path[500];
	
	return_fail_on_no_shared_memory
	printf("END:\t%s\n", str);
	printf("Points: %ld, Pass: %ld, Fail: %ld, Unresolved: %ld, Errors:%ld\n",
		test_info->test_results[POINT],
		test_info->test_results[PASS],
		test_info->test_results[FAIL],
		test_info->test_results[UNRES],
		test_info->test_results[ERROR]);
	
	if (munmap(test_info, sizeof(test_info)) != EOK) {
		error_print("munmap", errno);
		return EXIT_FAILURE;
	}
	
	/* set the shared memory path to ${SHMEM_PATH}_${PID} */
	sprintf(shmem_path, "%s_%d", SHMEM_PATH, getpid());
	
	if (shm_unlink(shmem_path) != EOK) {
		error_print("shm_unlink", errno);
		return EXIT_FAILURE;
	}
	
	test_info = NULL;
	
	return EXIT_SUCCESS;
}
